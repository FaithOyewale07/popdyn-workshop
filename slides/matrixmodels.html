<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Population Projection Models (PPMs)</title>
    <meta charset="utf-8" />
    <meta name="author" content="Sarah Cubaynes for the Team" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="slides-theme.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, title-slide

# Population Projection Models (PPMs)
### Sarah Cubaynes for the Team
### last updated: 2022-02-25

---




# What we've learned during this class

### Obj. 1: Know current and past trends in population abundance
- see class 1

--

### Obj. 2: Estimate demographic parameters and identify the causes of variation
- see class 2

--

### Obj. 3: Evaluate population viability to inform decision about management actions
- some hints about this now!

---
# Population Viability Analysis (PVA)


+ use of **quantitative methods** to predict the **likely future status** of a population or collection of populations of conservation concern 


+ **tentative assessments** based upon what we now know **rather than as iron-clad predictions **of population fate


---
# Why is PVA useful ? 

+ quantify the rate of population change over time

--

+ estimate extinction risks (used by the IUCN)

--

+ identify key parameters for population management

--

+ evaluate and compare the relative impact of population management actions

---
# Can we assess population viability from population counts ?

&lt;img src="img/pop_size.png" width="60%" style="display: block; margin: auto;" /&gt;

---
class: center, middle

# 1- Count based PVA

---
# Finite population growth rate `\(\lambda\)`

.pull-left[

&lt;img src="matrixmodels_files/figure-html/unnamed-chunk-2-1.png" style="display: block; margin: auto;" /&gt;

]

.pull-right[

- exponential growth or decay at a constant rate of change

- `\(\lambda = \frac{N_{t+1}}{N_{t}}\)` gives the **proportional change** in population size

- after t time steps, the population will be `\(N_{t} = N_{0} \cdot \lambda^{t}\)`

- `\(\lambda\)` is log-normally distributed

]

---

# Growth rate versus intrinsic rate of increase

- **Population growth rate** `\(\lambda \sim Lognormal(\mu,\sigma^{2})\)`

- easier to work with the **intrinsic rate of increase** 
`$$r = \log(\lambda) = \log(\frac{N_{t+1}}{N_{t}}) = \log(N_{t+1}) - \log(N_{t})$$`

--

- which is normally distributed
`\(r \sim N(\mu,\sigma^{2})\)`

--
- `\(\mu\)` is the **mean rate of increase** 

- `\(\sigma^{2}\)` is the **environmental variance**


---
# Environmental variance

- if the mean rate of increase `\(\mu &lt; 0\)` extinction will certainly occur. 

--

- a population can still decline or go extinct even if the mean rate of increase `\(\mu&gt;0\)` because of environmental variance `\(\sigma^{2}\)`.

--
- variable environments increase extinction risks.


---
## Example of the Yellowstone grizzly bear population 

.pull-left[
&lt;img src="matrixmodels_files/figure-html/unnamed-chunk-3-1.png" width="100%" /&gt;
]

.pull-right[
&lt;img src="img/famous-grizzly-bear-399-her-600w-1826571545.jpg" width="60%" style="display: block; margin: auto;" /&gt;
]

---
# Step 1 : Calculate `\(\mu\)` and `\(\sigma^{2}\)`  from the data


```r
# rate of increase over years
logN &lt;- log(N[-1]/N[-length(N)]) # log(Nt+1) - log(Nt)
#mean rate of increase
*mu = mean(logN)
#environmental variance
*sigma2 = var(logN)
```


```
          mu     sigma2
1 0.02134027 0.01305092
```

--

- `\(\mu &gt;0\)` in average the population is growing

--

- `\(\sigma^{2} = 0.013\)` reflect low inter-annual variance in the rate of increase


---
## or using linear regression for unequal time intervals


```r
x &lt;- sqrt(grizzly$year[-1] - grizzly$year[-length(grizzly$year)]) # sqrt time intervals
y &lt;- logN / x
mod &lt;- lm(y ~ 0 + x) # forcing a y-intercept of zero
mod
```

```

Call:
lm(formula = y ~ 0 + x)

Coefficients:
      x  
0.02134  
```

```r
mu &lt;- coef(mod) # the slope = mean intrinsic rate of increase
```

---
## or using linear regression for unequal time intervals


```r
# get an estimate for sigma2
anova(mod)
```

```
Analysis of Variance Table

Response: y
          Df  Sum Sq  Mean Sq F value Pr(&gt;F)
x          1 0.01731 0.017306   1.326 0.2569
Residuals 37 0.48288 0.013051               
```

```r
sigma2 &lt;- anova(mod)[["Mean Sq"]][2] # environmental variance
```

---

## Get confidence intervals for `\(\mu\)` and `\(\sigma_{2}\)`


```r
## Confidence interval for mu
confint(mod, 1)
```

```
        2.5 %     97.5 %
x -0.01620969 0.05889023
```
- confidence interval of mean rate of increase encompasses 0, we cannot rule out potential risk of decline!

--


```r
## Confidence interval for sigma 2
df1 &lt;- length(logN) - 1
df1 * sigma2 / qchisq(c(.975, .025), df = df1)
```

```
[1] 0.008674359 0.021844393
```


---

## Back-transform to get finite population growth rate `\(\bar{\lambda}\)`  :
 

```r
lambda &lt;- exp(mu) 
lambda # average growth rate
```

```
      x 
1.02157 
```

--

- here `\(\bar{\lambda} &gt; 1\)`, so the grizzly population is growing in average

- it does not rule out the possibility of a decline owing to the chance occurrence of a sequence of bad years (remember confidence interval)

---

# Step 2 : Project the population

- Expected population size using mean rate of increase and ignoring environmental variance (not recommended)

`$$N_{t} =  N_{0} \cdot \lambda^{t}$$`

`$$ln(N_{t}) =  ln(N_{0}) + \mu \cdot t$$`

--

* initial population `\(N_{0}=44\)`

* time steps to project over : `\(t =38\)` years (nb. years - 1)

* mean rate of increase `\(\mu = 0.021\)` 
---
# Step 2 : Project the population

&lt;img src="matrixmodels_files/figure-html/unnamed-chunk-12-1.png" width="50%" style="display: block; margin: auto;" /&gt;

---
# Step 2 : Project the population
## Let's account for observed variation in growth rate

- First, set the initial population, number of time steps, and number of repetitions: 


```r
n0 = grizzly$N[1] # initial pop.

T=50 # time iterations to project over

runs=500  # number of repetitions (pop. trajectories)

stoch.pop=matrix(NA,T,runs) # to store resuts       
stoch.pop[1,]=n0 # initiate
```

---
# Step 2 : Project the population
## Let's account for observed variation in growth rate


- Then set a quasi-extinction threshold 


```r
Ne = 30  # threshold for minimum viable pop. / quasi-extinction threshold
#48 from USFWS Grizzly Bear Recovery Plan to 'uplist' the bear from threatened status.
```

--
- 1 female or a minimum viable population (genetic drift, demographic stochasticity)

- can also be the lowest level of abundance at which it remains feasible to attempt intervention to prevent further decline. 

---
## Now run the projections

```r
# let's project the population
*for (i in 1:runs){
* for (t in 2:T){
# Draw r from normal using estimates of mu and sigma2
        r &lt;- rnorm(1,mu,sqrt(sigma2)) 
# back-transform to get lambda and get pop. size
    lambda=exp(r) 
#project one time step from the current pop size
    stoch.pop[t,i]=stoch.pop[(t-1),i]*lambda 
# leave the loop if pop &lt;= threshold
    if(stoch.pop[t,i]&lt;=Ne){ 
      stoch.pop[t,i] &lt;- 0 
      i&lt;i+1}  
  }
}
```

---
## Now run the projections

```r
# let's project the population
for (i in 1:runs){ # loop over repetitions
  for (t in 2:T){	# loop over years
# Draw r from normal using estimates of mu and sigma2
*       r &lt;- rnorm(1,mu,sqrt(sigma2))
# back-transform to get lambda and get pop. size
    lambda=exp(r) 
#project one time step from the current pop size
    stoch.pop[t,i]=stoch.pop[(t-1),i]*lambda 
# leave the loop if pop &lt;= threshold
    if(stoch.pop[t,i]&lt;=Ne){ 
      stoch.pop[t,i] &lt;- 0 
      i&lt;i+1}  
  }
}
```

---
## Now run the projections

```r
# let's project the population
for (i in 1:runs){ # loop over repetitions
  for (t in 2:T){	# loop over years
# Draw r from normal using estimates of mu and sigma2
        r &lt;- rnorm(1,mu,sqrt(sigma2)) 
# back-transform to get lambda and get pop. size
*   lambda=exp(r)
#project one time step from the current pop size
*   stoch.pop[t,i]=stoch.pop[(t-1),i]*lambda
# leave the loop if pop &lt;= threshold
    if(stoch.pop[t,i]&lt;=Ne){ 
      stoch.pop[t,i] &lt;- 0 
      i&lt;i+1}  
  }
}
```


---
## Now run the projections

```r
# let's project the population
for (i in 1:runs){ # loop over repetitions
  for (t in 2:T){	# loop over years
# Draw r from normal using estimates of mu and sigma2
        r &lt;- rnorm(1,mu,sqrt(sigma2)) 
# back-transform to get lambda and get pop. size
    lambda=exp(r)
#project one time step from the current pop size
    stoch.pop[t,i]=stoch.pop[(t-1),i]*lambda 
# leave the loop if pop &lt;= threshold
*   if(stoch.pop[t,i]&lt;=Ne){
*     stoch.pop[t,i] &lt;- 0
*     i&lt;i+1}
  }
}
```

---
# Step 3 : Examine the results

&lt;img src="matrixmodels_files/figure-html/unnamed-chunk-19-1.png" style="display: block; margin: auto;" /&gt;

---
# Step 3 : Examine the results

&lt;img src="matrixmodels_files/figure-html/message==FALSE-1.png" style="display: block; margin: auto;" /&gt;

---
# Step 3 : Examine the results

&lt;img src="matrixmodels_files/figure-html/unnamed-chunk-20-1.png" style="display: block; margin: auto;" /&gt;

---
# Step 3 : Examine the results

- The average population growth rate doesnâ€™t do a good job of predicting what most population realizations will do

--

- What are the chances that the population will go extinct at various times ? 

  + extinction risk
  
  + time to extinction
---
# Step 4 : Quantify extinction risks

- Ultimate extinction probability = percentage of trajectories (over the 500 runs) reaching the extinction threshold at some point (over T years)


```r
Pr.ext = sum(lastN &lt;= Ne) / runs # prob. to reach the extinction threshold
Pr.ext
```

```
[1] 0.214
```


---
# Step 4 : Quantify extinction risks
- Cumulative extinction risk over the years

&lt;img src="matrixmodels_files/figure-html/unnamed-chunk-22-1.png" width="45%" style="display: block; margin: auto;" /&gt;

---
# Step 5 : Quantify time to extinction
- mean time to extinction is an overestimation (because of few pop. growing fast)
- median time to extinction is a better measure


```r
# Time to reach extinction for extinct pop.
maxt&lt;-NULL	# empty vector to store results
for (i in 1:runs){	# loop over repetitions
  N &lt;- stoch.pop[,i]
  # max time N &gt; threshold
* maxt[i]&lt;-max(which(N&gt;0)) }
# time at extinction for pseudo-extinct populations
*time.ext &lt;- maxt[maxt&lt;T]
median(time.ext)
```

```
[1] 11
```

---
# Step 5 : Quantify time to extinction

![](matrixmodels_files/figure-html/unnamed-chunk-24-1.png)&lt;!-- --&gt;

---
# Step 6 : Perturb and run the model

## Interesting to evaluate the sensitivity of the results to changes :

- initial population size
- extinction threshold
- amount of environmental variance
- number of time steps

---
# Let's practice

- Run a PVA for the grizzly bear using 38 bears as the mimimum population size. 

- Start with the initial population of 99 bears in 1997.

- What is the probability that the population is extinct by 2022 ?

---
# Count based extinction analyses are based on strong hypotheses

- exhaustive counts (no sampling error)

--

- no density-dependence (exponential growth)

--

- only source of variation is environmental stochasticity (no demographic stochasticity, no trends in mean or variance over time, uncorrelated environment among successive  years)

--

- moderate environmental variability (no catastrophe, no bonanzas)

---
# Avantages

- simplicity (data requirement at least 10 censuses and calculation)
 
- work relatively well when assumptions are met
 
- assess model quality by hindcasting

---

# Limitations

- `\(\lambda\)` is only a summary of the population dynamics

--

- no info about the mechanisms governing the dynamics

--

- no hints about which management action might be most efficient? 

- Is it better to act on survival ? fecundity ? of adults ? juveniles ?

---
# Can we assess population viability from demographic parameters ?

&lt;img src="img/PPM.png" width="60%" style="display: block; margin: auto;" /&gt;

---
class: center, middle

# 2- PVA using Matrix Projection Models (MPMs)


---
# Let's assume no migrations for now 

- Survival and fecundity rates are enough to fully describe the population dynamics

`$$N_{t+1} = N_{t} * F + N_{t} * S$$`

  + F = fecundity
  + S = survival  (= 1- mortality)


---
# Demographic parameters (see class 2)

- demographic parameters are often **heterogeneous across the life cycle** : survival and fecundity vary with age and/or stage in many species.

&lt;img src="img/oak-tree.jpg" width="60%" style="display: block; margin: auto;" /&gt;



---

# Matrix Population Models (MPMs)

- Incorporate vital rates that are heterogeneous across the life cycle

- Project the population based on the matrix summarizing the age- or stage- dependent demographic parameters 

---

# The Barn swallow (*Hirundo rustica*) example

&lt;img src="img/barnswallowlifecycle.png" width="50%" style="display: block; margin: auto;" /&gt;

---
# Demographic parameters

Survival rates :
- `\(S_{0}\)` chick survival 
- `\(S_{1}\)` juvenile survival (1 yo)
- `\(S_{2}\)` adult survival (2+ yo)

Fecundity : 
- `\(F_{1}\)` number of females produced by a juvenile female
- `\(F_{2}\)` number of females produced by an adult female

---
# Timing of data collection ?

&lt;img src="img/PreBreeding.png" width="100%" style="display: block; margin: auto;" /&gt;

+ pre-breeding census

---
# Timing of data collection ?

&lt;img src="img/PostBreeding.png" width="100%" style="display: block; margin: auto;" /&gt;

+ post-breeding census

---

# Step 1 : write the agenda of events

+ Let's first consider a pre-breeding census


&lt;img src="img/AgendaPreB1.png" width="100%" style="display: block; margin: auto;" /&gt;

---

# Step 1 : write the agenda of events

+ Let's first consider a pre-breeding census

&lt;img src="img/AgendaPreB2.png" width="100%" style="display: block; margin: auto;" /&gt;

---

# Step 1 : write the agenda of events

+ Let's first consider a pre-breeding census

&lt;img src="img/AgendaPreB3.png" width="100%" style="display: block; margin: auto;" /&gt;
--
+ Note that newborn are not observed directly !

---
# Step 2 : Translate into life cycle graph or 'Caswell representation'

- a trick is to go 'up the arrows'

&lt;img src="img/preBLifeCycle.png" width="35%" style="display: block; margin: auto;" /&gt;

---

# Step 3 : Translate into equations

- Link `\(N_{(t+1)}\)` to `\(N_{(t)}\)` via survival and fertility rates
- a trick is to read the parameters going up the arrows

`\(N_{(1,t+1)} = F_{1} \cdot S_{0} \cdot N_{(1,t)}+ F_{2} \cdot S_{0} \cdot N_{(2,t)}\)`

`\(N_{(2,t+1)} = S_{1} . N_{(1,t)} + S_{2} . N_{(2,t)}\)`

---
# Step 3 : Arrange in a matrix format

+ called the **transition matrix**, or the **projection matrix** 


`$$N_{(t+1)} = \begin{bmatrix}F_{1} \cdot S_{0} &amp; F_{2} \cdot S_{0}\\
S_{1} &amp; S_{2}
\end{bmatrix} \cdot N_{(t)}$$`

---
# Step 3 : Arrange in a matrix format

+ with `\(S_{0} = 0.2\)`, `\(S_{1} = 0.5\)` and `\(S_{2} = 0.65\)`
+ `\(F_{1} = 3/2\)` and `\(F_{2} = 6/2\)`


`$$N_{(t+1)} = \begin{bmatrix}0.3 &amp; 0.6\\
0.5 &amp; 0.65
\end{bmatrix} \cdot N_{(t)}$$`

---
# Why is the matrix format interesting ? 

- easier to read than multiple equations

- intrinsic numeric features (back to it later)

- work the same way for complex life cycles 
  
---
# The projection matrix
- How many age classes / stages in the life cycle ?
- age at first reproduction ?
- maximum age at death fixed or not ?


&lt;img src="img/Leslie.png" width="60%" style="display: block; margin: auto;" /&gt;


---
# The projection matrix
- pre- or post-breeeding census ?

--

&lt;img src="img/PostBreeding.png" width="100%" style="display: block; margin: auto;" /&gt;

+ post-breeding census

---
# Step 1 : write the agenda of events

&lt;img src="img/AgendaPostB1.png" width="100%" style="display: block; margin: auto;" /&gt;

---

# Step 1 : write the agenda of events

&lt;img src="img/AgendaPostB2.png" width="100%" style="display: block; margin: auto;" /&gt;

---

# Step 1 : write the agenda of events

&lt;img src="img/AgendaPostB3.png" width="100%" style="display: block; margin: auto;" /&gt;
--
+ Note that newborn are now observed !

---
# Step 2 : Translate into life cycle graph or 'Caswell representation'

&lt;img src="img/postBLifeCycle.png" width="70%" style="display: block; margin: auto;" /&gt;

---

# Step 3 : Translate into equations

`\(N_{(0,t+1)} =  S_{0} \cdot F_{1} \cdot  N_{(0,t)} + S_{1} \cdot F_{2} \cdot N_{(1,t)}+ S_{2} \cdot F_{2} \cdot  N_{(2,t)}\)`

`\(N_{(1,t+1)} = S_{0} \cdot N_{(0,t)}\)`

`\(N_{(2,t+1)} = S_{1} \cdot N_{(1,t)} + S_{2} \cdot N_{(2,t)}\)`

--
# Step 4 : Arrange in a matrix format

`$$N_{(t+1)} = \begin{bmatrix} S_{0} \cdot F_{1} &amp; S_{1} \cdot F_{2} &amp; S_{2} \cdot F _{2} \\
S_{0} &amp; 0 &amp; 0 \\
0 &amp; S_{1} &amp; S_{2}\\
\end{bmatrix} \cdot N_{(t)}$$`

---
class: center, middle

# Let's practice writing life cycles

---



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"slideNumberFormat": ""
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
